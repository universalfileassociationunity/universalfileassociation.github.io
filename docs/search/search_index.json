{
    "docs": [
        {
            "location": "/", 
            "text": "Download from the Unity Asset Store\n | \nDownload Pro Version from the Unity Asset Store\n \n\n\nDiscord Support\n \u00a0| \nMail Contact\n\n\nImaginationOverflow \nUniversal File Association\n plugin enables your Unity apps and games to be configured as the default file handler (e.g .xpto, .pdf) on iOS, Android, Windows 10 (UWP), Standalone (Linux, Mac, and Windows) and tvOS.\n\n\nRegistering your app/game as the default file handler means that every time one of your users tries to open a registered file type, your app/game will be activated in order to process the file.\n\n\nEach platform has its own way of registering file types, some use mime-types, others plain old file extensions, Universal File Association handles all the configurations, you just need to configure which extensions you wish to register.\n\n\nGetting Started\n\n\n\n\nHow to Use\n\n\nConfiguring the Plugin\n\n\nTesting\n\n\n\n\nSteam Integration\n\n\n\n\nConfiguring the Plugin\n\n\nMac integration details\n\n\n\n\nInside the Plugin\n\n\n\n\nOverview\n\n\nDetails on all supported platforms", 
            "title": "Home"
        }, 
        {
            "location": "/#getting-started", 
            "text": "How to Use  Configuring the Plugin  Testing", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#steam-integration", 
            "text": "Configuring the Plugin  Mac integration details", 
            "title": "Steam Integration"
        }, 
        {
            "location": "/#inside-the-plugin", 
            "text": "Overview  Details on all supported platforms", 
            "title": "Inside the Plugin"
        }, 
        {
            "location": "/GettingStarted/", 
            "text": "Universal File Association\n plugin enables your Unity apps and games to be configured as the default file handler (e.g .xpto, .pdf) on iOS, Android, Windows 10 (UWP), Standalone (Linux, Mac, and Windows) and tvOS.\n\n\nUsing the Plugin\n\n\nThe plugin uses a single event where you need to register in order to receive file activations on all platforms:\n\n\nvoid\n \nStart\n()\n\n\n{\n\n    \nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nFileActivated\n \n+=\n \nFileActivatedHandler\n;\n\n\n}\n\n\n\nprivate\n \nvoid\n \nFileActivatedHandler\n(\nImaginationOverflow\n.\nUniversalFileAssociation\n.\nData\n.\nFileInformation\n \ns\n)\n\n\n{\n\n    \n//\n\n    \n//  my activation code\n\n    \n//\n\n\n}\n\n\n\nNever forget to remove your event registration when the \nGameObject\n where you registered it is \ndestroyed\n:\n\n\nvoid\n \nOnDestroy\n()\n\n\n{\n\n    \nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nFileActivated\n \n-=\n \nFileActivatedHandler\n;\n\n\n}\n\n\n\n\n\nThe \nFileActivated\n event will be triggered when your game is \nstarted\n or \nresumed\n by a file activation.\n\n\nThe \nFileActivated\n event single argument \nFileInformation\n contains the filename, path, size, extension and a Stream of the activated file: \n\n\npublic\n \nclass\n \nFileInformation\n\n\n{\n\n    \npublic\n \nStream\n \nStream\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n    \npublic\n \nstring\n \nPath\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n    \npublic\n \nstring\n \nName\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n    \npublic\n \nstring\n \nFileExtension\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n    \npublic\n \nulong\n \nSize\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n}\n\n\n\n\n\nConsider the following example:\n\n\nprivate\n \nvoid\n \nFileActivatedHandler\n(\nImaginationOverflow\n.\nUniversalFileAssociation\n.\nData\n.\nFileInformation\n \nfileActivated\n)\n\n\n{\n\n    \nvar\n \nsize\n \n=\n \nfileActivated\n.\nSize\n;\n\n    \nvar\n \nfileContent\n \n=\n \nnew\n \nStreamReader\n(\nfileActivated\n.\nStream\n).\nReadToEnd\n();\n\n    \nvar\n \nfileName\n \n=\n \nfileActivated\n.\nName\n;\n\n\n}\n\n\n\n\n\nThe \nFileInformation\n class of an activated file contains a \nStream\n that enables you to read the complete file content. In the example above, the variable \nfileContent\n would contain the full content of the file.\n\n\nDepending on the operating system and activation type it can be impossible to write on the file, check the \nInside the Plugin Section\n for more details on the operating systems and situations where writting is not possible.\n\n\nConfiguring the Plugin\n\n\nThe configuration interface is under \nWindow\n -\n \nImaginationOverflow\n -\n \nUniversal File Association\n -\n \nConfiguration\n\n\n\n\n\n\nOn some platforms, the operating system asks the player what app she wishes to use after opening a file, the \nDisplay Name\n allows you to configure what name will the OS show on that occasion.\nThe \nSteam App Id\n is for Steam only games, you can read about Steam integration on its \nsection\n. \nThe plugin allows you to configure the file association globally on a per-platform basis.\n\n\nGlobal Configuration\n\n\n\n\nIf you wish to register the same file associations for all your target platforms, you only require to configure the Global settings, the plugin will propagate all data to all platforms as you build for them.\n\n\nWhile you setup your required extensions the plugin will automatically match them with a \nMime Type\n or \nUIT\n, these relations between extensions and type format is required by some platforms (e.g iOS, Linux, Android).\n\n\nPer Platform Configuration\n\n\nWhen you wish to override any configuration for a specific platform you can do that by clicking on the specific platform checkbox. After that, you just need to fill out the File Association data or leave it empty if you do not wish to support these features for that specific platform. Note that by checking a platform none of the global configurations will be used for that specific platform. \n\n\n\n\nIn the example above, we've changed the \niOS\n \nfile extension\n to \nmyextios\n. The remaining platforms will continue to use the global configurations.\n\n\nTesting\n\n\nAfter your Unity app or game is deployed to a device, you can test the integration simply by opening a file from one of the types that you registered using the Universal File Association plugin.\n\n\nFor integration tests you can use our \nOnline Test Tool\n which allows you to create a simple text file with any extension, and download it directly to your device to be opened.\n\n\nAny third party file explorer or email application could also be used to open files and test the plugin integration.\n\n\nEditor\n\n\nWe included a simple interface where you can test your file association integration without deploying, to access it go to \nWindow\n -\n \nImaginationOverflow\n -\n \nUniversal File Association\n -\n \nDebug\n\n\n\n\nWhen you press \nDebug\n, the \nFileActivated\n will be triggered and your callback called if the application is running in the editor.\n\n\nStandalone Caveats\n\n\nBuild for MacOS\n\n\nIf you make your Mac builds on MacOS the plugin will automatically configure everything that is required in order for it to work correctly. But if you make your MacOs build on Windows you will need to do some extra steps in order to fully configure your build to receive file activations. Due to Unity limitations, you \nwill need a Mac or a MacOs VM\n in order to completely use the plugin capabilities.\n\n\nBuilding for MacOS on Windows\n\n\nWhen the build is completed you will note that the build process created an extra folder named \nUniversalFileAssociationScripts\n. This folder contains all tools required to correctly finish up the plugin configuration:\n\n\n\n\nCopy the \nUniversalFileAssociationScripts\n and your deliverable (\nyou_game.app\n) to your Mac or VM.\n\n\nOpen a Terminal and navigate to the copied items location.\n\n\nRun the setup.sh script:\n\n./setup.sh\n\n\n\n\n\nIf everything goes as expected you should see something similar to the following image:\n\n\n\nFor more information on why you need to do this extra step check our \nInside the Plugin Section\n.\n\n\nLinux and Windows\n\n\nOn Windows and Linux standalone builds, the File Association is only configured when the game runs the first time, so even if the player has the game installed on his machine, if he didn't play at least one time, the File association won't activate the app/game.\n\n\nWindows and Linux builds also only allow players to start your game via a File Association if the player opens a file after your game is already open the plugin won't react to this new activation. \n\n\nFor further details on why this happens, and how to work around it, you can check our \nInside the Plugin Section\n.\n\n\nNotes\n\n\n\n\nIf you don't own a mac you can always create a \nMac VM\n\n\nIf you are targetting a platform that the plugin doesn't support, you will find that building to an unsupported platform will yield an error stating that the assembly \nImaginationOverflow.UniversalFileAssociation.Platform.dll\n is not present. To fix this you will find a dummy assembly under Assets\\Plugins\\ImaginationOverflow\\UniversalFileAssociation\\libs\\Dummy, configure it to be included on the unsupported platform that you are targetting and the error should be fixed.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/GettingStarted/#using-the-plugin", 
            "text": "The plugin uses a single event where you need to register in order to receive file activations on all platforms:  void   Start ()  { \n     ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . FileActivated   +=   FileActivatedHandler ;  }  private   void   FileActivatedHandler ( ImaginationOverflow . UniversalFileAssociation . Data . FileInformation   s )  { \n     // \n     //  my activation code \n     //  }  \nNever forget to remove your event registration when the  GameObject  where you registered it is  destroyed :  void   OnDestroy ()  { \n     ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . FileActivated   -=   FileActivatedHandler ;  }   The  FileActivated  event will be triggered when your game is  started  or  resumed  by a file activation.  The  FileActivated  event single argument  FileInformation  contains the filename, path, size, extension and a Stream of the activated file:   public   class   FileInformation  { \n     public   Stream   Stream   {   get ;   set ;   } \n\n     public   string   Path   {   get ;   set ;   } \n\n     public   string   Name   {   get ;   set ;   } \n\n     public   string   FileExtension   {   get ;   set ;   } \n\n     public   ulong   Size   {   get ;   set ;   }  }   Consider the following example:  private   void   FileActivatedHandler ( ImaginationOverflow . UniversalFileAssociation . Data . FileInformation   fileActivated )  { \n     var   size   =   fileActivated . Size ; \n     var   fileContent   =   new   StreamReader ( fileActivated . Stream ). ReadToEnd (); \n     var   fileName   =   fileActivated . Name ;  }   The  FileInformation  class of an activated file contains a  Stream  that enables you to read the complete file content. In the example above, the variable  fileContent  would contain the full content of the file.  Depending on the operating system and activation type it can be impossible to write on the file, check the  Inside the Plugin Section  for more details on the operating systems and situations where writting is not possible.", 
            "title": "Using the Plugin"
        }, 
        {
            "location": "/GettingStarted/#configuring-the-plugin", 
            "text": "The configuration interface is under  Window  -   ImaginationOverflow  -   Universal File Association  -   Configuration    On some platforms, the operating system asks the player what app she wishes to use after opening a file, the  Display Name  allows you to configure what name will the OS show on that occasion.\nThe  Steam App Id  is for Steam only games, you can read about Steam integration on its  section . \nThe plugin allows you to configure the file association globally on a per-platform basis.", 
            "title": "Configuring the Plugin"
        }, 
        {
            "location": "/GettingStarted/#global-configuration", 
            "text": "If you wish to register the same file associations for all your target platforms, you only require to configure the Global settings, the plugin will propagate all data to all platforms as you build for them.  While you setup your required extensions the plugin will automatically match them with a  Mime Type  or  UIT , these relations between extensions and type format is required by some platforms (e.g iOS, Linux, Android).", 
            "title": "Global Configuration"
        }, 
        {
            "location": "/GettingStarted/#per-platform-configuration", 
            "text": "When you wish to override any configuration for a specific platform you can do that by clicking on the specific platform checkbox. After that, you just need to fill out the File Association data or leave it empty if you do not wish to support these features for that specific platform. Note that by checking a platform none of the global configurations will be used for that specific platform.    In the example above, we've changed the  iOS   file extension  to  myextios . The remaining platforms will continue to use the global configurations.", 
            "title": "Per Platform Configuration"
        }, 
        {
            "location": "/GettingStarted/#testing", 
            "text": "After your Unity app or game is deployed to a device, you can test the integration simply by opening a file from one of the types that you registered using the Universal File Association plugin.  For integration tests you can use our  Online Test Tool  which allows you to create a simple text file with any extension, and download it directly to your device to be opened.  Any third party file explorer or email application could also be used to open files and test the plugin integration.", 
            "title": "Testing"
        }, 
        {
            "location": "/GettingStarted/#editor", 
            "text": "We included a simple interface where you can test your file association integration without deploying, to access it go to  Window  -   ImaginationOverflow  -   Universal File Association  -   Debug   When you press  Debug , the  FileActivated  will be triggered and your callback called if the application is running in the editor.", 
            "title": "Editor"
        }, 
        {
            "location": "/GettingStarted/#standalone-caveats", 
            "text": "", 
            "title": "Standalone Caveats"
        }, 
        {
            "location": "/GettingStarted/#build-for-macos", 
            "text": "If you make your Mac builds on MacOS the plugin will automatically configure everything that is required in order for it to work correctly. But if you make your MacOs build on Windows you will need to do some extra steps in order to fully configure your build to receive file activations. Due to Unity limitations, you  will need a Mac or a MacOs VM  in order to completely use the plugin capabilities.", 
            "title": "Build for MacOS"
        }, 
        {
            "location": "/GettingStarted/#building-for-macos-on-windows", 
            "text": "When the build is completed you will note that the build process created an extra folder named  UniversalFileAssociationScripts . This folder contains all tools required to correctly finish up the plugin configuration:   Copy the  UniversalFileAssociationScripts  and your deliverable ( you_game.app ) to your Mac or VM.  Open a Terminal and navigate to the copied items location.  Run the setup.sh script: ./setup.sh   If everything goes as expected you should see something similar to the following image:  For more information on why you need to do this extra step check our  Inside the Plugin Section .", 
            "title": "Building for MacOS on Windows"
        }, 
        {
            "location": "/GettingStarted/#linux-and-windows", 
            "text": "On Windows and Linux standalone builds, the File Association is only configured when the game runs the first time, so even if the player has the game installed on his machine, if he didn't play at least one time, the File association won't activate the app/game.  Windows and Linux builds also only allow players to start your game via a File Association if the player opens a file after your game is already open the plugin won't react to this new activation.   For further details on why this happens, and how to work around it, you can check our  Inside the Plugin Section .", 
            "title": "Linux and Windows"
        }, 
        {
            "location": "/GettingStarted/#notes", 
            "text": "If you don't own a mac you can always create a  Mac VM  If you are targetting a platform that the plugin doesn't support, you will find that building to an unsupported platform will yield an error stating that the assembly  ImaginationOverflow.UniversalFileAssociation.Platform.dll  is not present. To fix this you will find a dummy assembly under Assets\\Plugins\\ImaginationOverflow\\UniversalFileAssociation\\libs\\Dummy, configure it to be included on the unsupported platform that you are targetting and the error should be fixed.", 
            "title": "Notes"
        }, 
        {
            "location": "/SteamIntegration/", 
            "text": "Regular Standalone File Activation opens up your game when someone clicks on a file you registered as the default handler. But if your game is on Steam you are probably using its SDK or DRM capabilities to further enhance your players' experience.\n\n\nIf you open a Steam game from its installation folder, since it wasn't open via steam it probably won't be able to communicate with valve software in order to report achievements, stats, etc, or it won't simply launch due to the DRM feature.\n\n\nSo using the regular File Activation mechanism where we associate a file type to a game executable wouldn't work since the game would possibly lose functionality or simply wouldn't start.\n\n\nTo avoid this issue, instead of registering your game to your desired file type, we configure the target systems to open steam instead of your game, but we parameterize Steam to open your game as soon as it's initialized.\n\n\nConfiguring Steam Integration\n\n\nTo enable the Steam capability of ImaginationOverflow File Association Plugin you first need to have a valid app id, for that you need to get access to \nSteam Direct\n. After that valve will attribute to your game an ID.\n\n\n\n\nAs an example, Sudoku Zenkai id is \n809850\n. \n\n\nThen you need to configure the plugin with this id:\n\n\n\n\nThe final step of the configuration to enable the Steam integration is setting the \nIsSteamBuild\n Property under \nFileAssociationManager\n:\n\n\nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nIsSteamBuild\n \n=\n \ntrue\n;\n\n\n\n\n\nIf your game is on Steam there is a good chance that you offer DRM-free versions of it on other stores, so don't forget to turn off this option when making DRM-free standalone builds, a good way to do this automatically is using \ncompilation flags\n.\n\n\n#if STEAM_BUILD\n\n\nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nIsSteamBuild\n \n=\n \ntrue\n;\n\n\n#else\n\n\nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nIsSteamBuild\n \n=\n \nfalse\n;\n\n\n#endif\n\n\n\n\n\nMac and Steam Integration\n\n\nMac File Association works a little different from the Windows and Linux, you have to take special care when integrating the plugin with Mac and Steam. On Linux and Windows, the plugin handles the registration of the File Types when the game is first open. This enables the plugin to register whatever it wants on these platforms. On Mac, the file activation feature is fully controlled by the OS and the plugin can't change the default configuration, which opens your game directly.\n\n\nThe OS itself doesn't know that is running a Steam game, so when the user clicks on a configured file type, the OS opens the game executable. This means that you need to explicitly delay the enforcement of the DRM until you know if the game was activated via file association or not.\n\n\nThe plugin is configured in a way that when it's running a Steam game on MacOS \nit will always\n fire the FileActivated event even if the game wasn't activated via file activation. This way is possible to store the file info before enforcing any DRM in the game. \n\n\nSolution Suggestion\n\n\nBelow is the code that we use on Sudoku Zenkai to handle this tricky issue, for Steam integration we are using \nSteamworks.NET\n.\n\n\nThe user flow for this situation is the following:\n\n\n\n\nUser clicks on a file type.\n\n\nThe game opens\n\n\nThe game enforces DRM and launches the game on Steam.\n\n\nSteam launches (if not already running).\n\n\nSteam launches the game.\n\n\n\n\nTo ensure that we process the file that the user initially clicked we need to save it before enforcing the DRM, in the code below we do exactly that:\n\n\n\n\nThe game is activated via file activation.\n\n\nThe FileActivated event is triggered.\n\n\nSave the file information (since it's impossible to have the game launch on steam via file activation)\n\n\nCheck if the game has steam access, if not restart.\n\n\nIf we are already on steam, load the previously saved activation\n\n\nResume file activation.\n\n\n\n\nThis behavior is only possible because \nthe plugin always triggers\n the FileActivated event (on Steam Mac builds) regardless if it was activated via a file activation or not.\n\n\n    \npublic\n \nvoid\n \nRegisterForActivation\n()\n\n    \n{\n\n\n#if UNITY_STANDALONE_OSX \n STEAM_BUILD\n\n        \nFileAssociationManager\n.\nInstance\n.\nFileActivated\n \n+=\n \nSteamOsxActivation\n;\n\n\n#else\n\n        \nFileAssociationManager\n.\nInstance\n.\nFileActivated\n \n+=\n \nInstance_FileActivated\n;\n\n\n#endif\n\n    \n}\n\n\n    \nprivate\n \nvoid\n \nSteamOsxActivation\n(\nFileInformation\n \ns\n)\n\n    \n{\n\n        \n//\n\n        \n//  On Steam OSX builds the plugin triggers the FileActivated with the  \n\n        \n//  file information or with a null Path if it wasn\nt activated \n\n        \n//  via a file\n\n        \n//\n\n        \nif\n \n(\nstring\n.\nIsNullOrEmpty\n(\ns\n.\nPath\n)\n \n==\n \nfalse\n)\n\n            \nYourGameStorage\n.\nSaveFileActivation\n(\ns\n);\n\n\n        \n//\n\n        \n//  Enforce DRM\n\n        \n//\n\n        \nif\n \n(\nSteamworks\n.\nSteamAPI\n.\nRestartAppIfNecessary\n(\nnew\n \nSteamworks\n.\nAppId_t\n([\nYourAppId\n])))\n\n        \n{\n\n            \nApplication\n.\nQuit\n();\n\n            \nreturn\n;\n\n        \n}\n\n\n        \n//\n\n        \n//  We are already running on Steam, so load any saved file activations\n\n        \n//\n\n        \ns\n \n=\n \nYourGameStorage\n.\nLoadSavedFileActiation\n();\n\n\n        \nif\n \n(\ns\n \n==\n \nnull\n)\n\n            \nreturn\n;\n\n\n        \n//\n\n        \n//  Clear the activation ensuring that the game won\nt be activated again \n\n        \n//  with the same file, this will depend on your storage infrastructure.\n\n        \n//  \n\n        \nYourGameStorage\n.\nClearActivation\n();\n\n\n        \n//\n\n        \n//  Process file activation\n\n        \n//\n\n        \nInstance_FileActivated\n(\ns\n);\n\n    \n}\n\n\n\n\n\nThis behavior only happens when the game is running on Mac and you set the Steam flag to true, on the other combinations the plugin only fires the FileActivated event in case of an actual activation.", 
            "title": "Steam Integration"
        }, 
        {
            "location": "/SteamIntegration/#configuring-steam-integration", 
            "text": "To enable the Steam capability of ImaginationOverflow File Association Plugin you first need to have a valid app id, for that you need to get access to  Steam Direct . After that valve will attribute to your game an ID.   As an example, Sudoku Zenkai id is  809850 .   Then you need to configure the plugin with this id:   The final step of the configuration to enable the Steam integration is setting the  IsSteamBuild  Property under  FileAssociationManager :  ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . IsSteamBuild   =   true ;   If your game is on Steam there is a good chance that you offer DRM-free versions of it on other stores, so don't forget to turn off this option when making DRM-free standalone builds, a good way to do this automatically is using  compilation flags .  #if STEAM_BUILD  ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . IsSteamBuild   =   true ;  #else  ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . IsSteamBuild   =   false ;  #endif", 
            "title": "Configuring Steam Integration"
        }, 
        {
            "location": "/SteamIntegration/#mac-and-steam-integration", 
            "text": "Mac File Association works a little different from the Windows and Linux, you have to take special care when integrating the plugin with Mac and Steam. On Linux and Windows, the plugin handles the registration of the File Types when the game is first open. This enables the plugin to register whatever it wants on these platforms. On Mac, the file activation feature is fully controlled by the OS and the plugin can't change the default configuration, which opens your game directly.  The OS itself doesn't know that is running a Steam game, so when the user clicks on a configured file type, the OS opens the game executable. This means that you need to explicitly delay the enforcement of the DRM until you know if the game was activated via file association or not.  The plugin is configured in a way that when it's running a Steam game on MacOS  it will always  fire the FileActivated event even if the game wasn't activated via file activation. This way is possible to store the file info before enforcing any DRM in the game.", 
            "title": "Mac and Steam Integration"
        }, 
        {
            "location": "/SteamIntegration/#solution-suggestion", 
            "text": "Below is the code that we use on Sudoku Zenkai to handle this tricky issue, for Steam integration we are using  Steamworks.NET .  The user flow for this situation is the following:   User clicks on a file type.  The game opens  The game enforces DRM and launches the game on Steam.  Steam launches (if not already running).  Steam launches the game.   To ensure that we process the file that the user initially clicked we need to save it before enforcing the DRM, in the code below we do exactly that:   The game is activated via file activation.  The FileActivated event is triggered.  Save the file information (since it's impossible to have the game launch on steam via file activation)  Check if the game has steam access, if not restart.  If we are already on steam, load the previously saved activation  Resume file activation.   This behavior is only possible because  the plugin always triggers  the FileActivated event (on Steam Mac builds) regardless if it was activated via a file activation or not.       public   void   RegisterForActivation () \n     {  #if UNITY_STANDALONE_OSX   STEAM_BUILD \n         FileAssociationManager . Instance . FileActivated   +=   SteamOsxActivation ;  #else \n         FileAssociationManager . Instance . FileActivated   +=   Instance_FileActivated ;  #endif \n     } \n\n     private   void   SteamOsxActivation ( FileInformation   s ) \n     { \n         // \n         //  On Steam OSX builds the plugin triggers the FileActivated with the   \n         //  file information or with a null Path if it wasn t activated  \n         //  via a file \n         // \n         if   ( string . IsNullOrEmpty ( s . Path )   ==   false ) \n             YourGameStorage . SaveFileActivation ( s ); \n\n         // \n         //  Enforce DRM \n         // \n         if   ( Steamworks . SteamAPI . RestartAppIfNecessary ( new   Steamworks . AppId_t ([ YourAppId ]))) \n         { \n             Application . Quit (); \n             return ; \n         } \n\n         // \n         //  We are already running on Steam, so load any saved file activations \n         // \n         s   =   YourGameStorage . LoadSavedFileActiation (); \n\n         if   ( s   ==   null ) \n             return ; \n\n         // \n         //  Clear the activation ensuring that the game won t be activated again  \n         //  with the same file, this will depend on your storage infrastructure. \n         //   \n         YourGameStorage . ClearActivation (); \n\n         // \n         //  Process file activation \n         // \n         Instance_FileActivated ( s ); \n     }   This behavior only happens when the game is running on Mac and you set the Steam flag to true, on the other combinations the plugin only fires the FileActivated event in case of an actual activation.", 
            "title": "Solution Suggestion"
        }, 
        {
            "location": "/Internals/", 
            "text": "On this section, we talk a little on how the plugin works on each platform and explain why it has some caveats on some platforms. \n\n\nOverview\n\n\n\n\nThe plugin content can be found inside the folder \nPlugins/ImaginationOverflow/UniversalFileAssociation\n, making easy to install and update when required. \n\n\nWe included a simple \nDemo\n scene that allows you to test and play with the plugin before integrating it in your game.\n\n\nInside the \nlibs\n folder os all the required dlls in order for the plugin to work:\n\n\n\n\nImaginationOverflow.UniversalFileAssociation*\n.dll* - Contains the public API of the plugin\n\n\n.Core.dll\n - Contains the core elements of the plugin\n\n\n.Editor.dll\n - Contains the windows and user interface of the plugin\n\n\n.Platform.dll\n - Contains the specific implementation for each platform, Android, iOS, UWP and Standalone.\n\n\n\n\nThe \nTools\n folder contains external tools that the plugin requires in order to work correctly, right now, the only external tool we are using is \noptool\n, required for MacOs builds.\n\n\nThe plugin configurations are saved under \nResources/ImaginationOverflow/UniversalFileAssociation\n, facilitating the use of source control systems on development. This file is also required on some build targets at runtime, reason why it's directly under the Resources folder.\n\n\nRuntime\n\n\nAt runtime the plugin creates a single \nGameObject\n and adds it to your current scene, this GameObject purpose is to ensure that all activation callbacks are called inside Unity main thread as well as propagate the \npause\n events of the game to the plugin. The latter enables the plugin to refresh the activation data on some mobile platforms.\n\n\nAndroid\n\n\nThe plugin handles all manifest registrations when you make a build, the plugin \ndoesn't\n override the default activity enabling it to work with the most used plugins in the Asset Store. The File Association activation is checked everytime the game is opened or resumed.\n\n\niOS/tvOS\n\n\nThe iOS integration uses a static library \nlibIOUniversalFileAssociationLibrary.a\n in order to receive information about the app activation. Just like on Android the plugin handles all registrations on the \ninfo.plist\n file. The library included in the plugin notifies it everytime the game was opened via a file activation.\n\n\nWindows UWP (Windows Store Games)\n\n\nJust like the previous mobile platforms, the plugin automatically configures the \nPackage.appxmanifest\n file with your configuration. \n\n\nIn order for the plugin to work it edits the OnActivated event under \nApp.xaml.cs\n, \nApp.xaml.cpp\n or \nApp.cpp\n depending on what \nBuild Type\n (Xaml or D3D) and \nScripting Backend\n (.NET or IL2CPP) you configure. The plugin should also work on \nXbox UWP\n games but it was impossible to test on an actual console in order to get confirmation.\n\n\nLinux and Windows\n\n\nOn Linux the file type registration is done the \nfirst time the player opens the game\n. To accomplish this the plugin creates a \nDesktop File\n on the player machine, enabling the operating system to set up the game as a target of a custom file type or mime type. \n\n\nWindows, the game writes in the registry the information necessary to enable the OS to open the game every time the player clicks on a configured file type.\n\n\nThe protocol registration is also done everytime the \nApplication.version\n is changed, enabling you to change the configuration with an update. \n\n\nIf the game build is for Steam, the plugin configures Steam to be the target of your custom file type instead of the game (this is done to work around DRM) but configures Steam to launch your game with the file that opened steam.\n\n\nLinux and Windows builds (Steam or Standalone) can't be activated via a file \nafter the game is already running.\n This is because the file activation information is passed via argument on the \nmain\n function, making it impossible (right now at least) to get information of the file path after the game is already running. To work around this issue check the section below:\n\n\nStandalone activation after launch\n\n\nAlthough not included with the plugin, it's possible to work around the activation issue. In order to do that it's required that another application (Launcher application) is registered as the target for the file type and that activation is responsible to launch or notify your app or game. So instead of the normal activation flow:\n\n\n\n\nIt will run like the following\n\n\n\n\nThe Launcher application is not included in the plugin for security and liability reasons, so you would need to develop it yourself and include it on your game/app final package. \nWe do however have an API for enabling this kind of behavior.\n\n\nFirst off, you would need to register the launcher application instead of your app/game as the target application for the plugin, in order to facilitate that we enable you to override what we register as the file type target, your app/game executable or another application.\n\n\nIn order to do that, before you register your callback on the \nFileActivated\n event you need to set the \nDeferredExePath\n field with the full path of the application.\n\n\n#if UNITY_STANDALONE_LINUX || UNITY_STANDALONE_WIN\n\n    \nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationProviderFactory\n.\nDeferredExePath\n \n=\n \nLauncher application full path\n;\n\n\n#endif\n\n    \nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nFileActivated\n \n+=\n \nFileActivatedHandler\n;\n\n\n\n\n\nThen you need to implement a bridge between the Launcher application and your app/game, for this situation any common \nInter Process Communication\n tools or APIs can be used, you can as an example use, \nFiles\n, \nSockets\n or \nPipes\n.\n\n\nUsing the file polling as an example, the launcher application would write the \nactivation file path\n on a file that both the launcher and your app/game knows. The game would then\non set intervals check if a specific file was changed when it was changed the app/game would read it in order to get the activation file. After getting the file path the app/game could use our manual trigger API in order to activate the \nFileActivated\n event:\n\n\nwhile\n(\ntrue\n)\n\n\n{\n\n    \nif\n(\nfile\n \nwas\n \nmodified\n)\n\n    \n{\n\n        \nstring\n \nfilePath\n \n=\n \nSystem\n.\nIO\n.\nFile\n.\nReadAllText\n(\nfile\n \npath\n);\n\n        \nImaginationOverflow\n.\nUniversalFileAssociation\n.\nFileAssociationManager\n.\nInstance\n.\nManuallyTriggerActivation\n(\nfilePath\n,\n \nnew\n \nStringReader\n(\nfilePath\n),\n \n(\nulong\n)\nnew\n \nFileInfo\n(\nfilePath\n).\nLength\n;);\n\n    \n}\n\n\n}\n\n\n\n\n\nThe launcher application needs to check if the app/game is open or not before deciding which method it would use in order to send the activation data to it. If the application is not running, you can simply launch it and pass the \nactivated file path\n as an argument. If the app/game is already running, you need to IPC in order to send information to the running app/game. Using the file polling example again, the launcher application code can be something like:\n\n\nvoid\n \nMain\n(\nstring\n[]\n \nargs\n)\n\n\n{\n\n    \nif\n(\nargs\n.\nLength\n \n==\n \n0\n)\n\n        \nreturn\n;\n\n\n    \n//  Get the activation file path.\n\n    \nvar\n \nfilePath\n \n=\n \nargs\n[\n1\n];\n\n\n    \n//  Check if your app/game is running\n\n    \nif\n(\nProcess\n.\nGetProcessesByName\n(\nyour app/game\n).\nLength\n \n==\n \n0\n)\n\n    \n{\n\n        \n//if not simply launch it with the file path as argument\n\n        \nProcess\n \np\n \n=\n \nnew\n \nProcess\n();\n\n        \np\n.\nStartInfo\n \n=\n \nnew\n \nProcessStartInfo\n(\npath to app/game executable\n,\n \nfilePath\n);\n\n        \np\n.\nStart\n();\n\n    \n}\n\n    \nelse\n\n    \n{\n   \n        \n//\n\n        \n//  Write in the share file the file path so that the app/game can extract it\n\n        \n//\n\n        \nFile\n.\nWriteAllText\n(\nPath to shared file between launcher and game\n,\n \nfilePath\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\nMac\n\n\nAll manifest registrations are handled by the plugin, the file activation is deferred from our library into the game as it happens, so MacOs builds won't have the caveats that Windows and Linux have.\n\n\nIn order to support file activation we had to make a \nlibrary\n (\nUniversalFileAssociation.framework\n) that would intercept the activation events of the application itself since Unity doesn't allow the plugin to automatically link a library on the build process it must be done after the build. To make that possible the plugin includes the tool \noptool\n. \n\n\noptool allow us to inject the library into the game and collect all the activation events. If you build your game on MacOs the plugin \nwill automatically\n call optool and inject the library. If you make the build on any other OS you will need to make an extra step, just has explained on the \nGetting Started Section\n. \n\n\nThis requirement exists because optool was made for MacOs and the team couldn't in useful time port it to Windows.\n\n\nFor more info about how the library injection works check \nhere\n.", 
            "title": "Inside the Plugin"
        }, 
        {
            "location": "/Internals/#overview", 
            "text": "The plugin content can be found inside the folder  Plugins/ImaginationOverflow/UniversalFileAssociation , making easy to install and update when required.   We included a simple  Demo  scene that allows you to test and play with the plugin before integrating it in your game.  Inside the  libs  folder os all the required dlls in order for the plugin to work:   ImaginationOverflow.UniversalFileAssociation* .dll* - Contains the public API of the plugin  .Core.dll  - Contains the core elements of the plugin  .Editor.dll  - Contains the windows and user interface of the plugin  .Platform.dll  - Contains the specific implementation for each platform, Android, iOS, UWP and Standalone.   The  Tools  folder contains external tools that the plugin requires in order to work correctly, right now, the only external tool we are using is  optool , required for MacOs builds.  The plugin configurations are saved under  Resources/ImaginationOverflow/UniversalFileAssociation , facilitating the use of source control systems on development. This file is also required on some build targets at runtime, reason why it's directly under the Resources folder.", 
            "title": "Overview"
        }, 
        {
            "location": "/Internals/#runtime", 
            "text": "At runtime the plugin creates a single  GameObject  and adds it to your current scene, this GameObject purpose is to ensure that all activation callbacks are called inside Unity main thread as well as propagate the  pause  events of the game to the plugin. The latter enables the plugin to refresh the activation data on some mobile platforms.", 
            "title": "Runtime"
        }, 
        {
            "location": "/Internals/#android", 
            "text": "The plugin handles all manifest registrations when you make a build, the plugin  doesn't  override the default activity enabling it to work with the most used plugins in the Asset Store. The File Association activation is checked everytime the game is opened or resumed.", 
            "title": "Android"
        }, 
        {
            "location": "/Internals/#iostvos", 
            "text": "The iOS integration uses a static library  libIOUniversalFileAssociationLibrary.a  in order to receive information about the app activation. Just like on Android the plugin handles all registrations on the  info.plist  file. The library included in the plugin notifies it everytime the game was opened via a file activation.", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/Internals/#windows-uwp-windows-store-games", 
            "text": "Just like the previous mobile platforms, the plugin automatically configures the  Package.appxmanifest  file with your configuration.   In order for the plugin to work it edits the OnActivated event under  App.xaml.cs ,  App.xaml.cpp  or  App.cpp  depending on what  Build Type  (Xaml or D3D) and  Scripting Backend  (.NET or IL2CPP) you configure. The plugin should also work on  Xbox UWP  games but it was impossible to test on an actual console in order to get confirmation.", 
            "title": "Windows UWP (Windows Store Games)"
        }, 
        {
            "location": "/Internals/#linux-and-windows", 
            "text": "On Linux the file type registration is done the  first time the player opens the game . To accomplish this the plugin creates a  Desktop File  on the player machine, enabling the operating system to set up the game as a target of a custom file type or mime type.   Windows, the game writes in the registry the information necessary to enable the OS to open the game every time the player clicks on a configured file type.  The protocol registration is also done everytime the  Application.version  is changed, enabling you to change the configuration with an update.   If the game build is for Steam, the plugin configures Steam to be the target of your custom file type instead of the game (this is done to work around DRM) but configures Steam to launch your game with the file that opened steam.  Linux and Windows builds (Steam or Standalone) can't be activated via a file  after the game is already running.  This is because the file activation information is passed via argument on the  main  function, making it impossible (right now at least) to get information of the file path after the game is already running. To work around this issue check the section below:", 
            "title": "Linux and Windows"
        }, 
        {
            "location": "/Internals/#standalone-activation-after-launch", 
            "text": "Although not included with the plugin, it's possible to work around the activation issue. In order to do that it's required that another application (Launcher application) is registered as the target for the file type and that activation is responsible to launch or notify your app or game. So instead of the normal activation flow:   It will run like the following   The Launcher application is not included in the plugin for security and liability reasons, so you would need to develop it yourself and include it on your game/app final package. \nWe do however have an API for enabling this kind of behavior.  First off, you would need to register the launcher application instead of your app/game as the target application for the plugin, in order to facilitate that we enable you to override what we register as the file type target, your app/game executable or another application.  In order to do that, before you register your callback on the  FileActivated  event you need to set the  DeferredExePath  field with the full path of the application.  #if UNITY_STANDALONE_LINUX || UNITY_STANDALONE_WIN \n     ImaginationOverflow . UniversalFileAssociation . FileAssociationProviderFactory . DeferredExePath   =   Launcher application full path ;  #endif \n     ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . FileActivated   +=   FileActivatedHandler ;   Then you need to implement a bridge between the Launcher application and your app/game, for this situation any common  Inter Process Communication  tools or APIs can be used, you can as an example use,  Files ,  Sockets  or  Pipes .  Using the file polling as an example, the launcher application would write the  activation file path  on a file that both the launcher and your app/game knows. The game would then\non set intervals check if a specific file was changed when it was changed the app/game would read it in order to get the activation file. After getting the file path the app/game could use our manual trigger API in order to activate the  FileActivated  event:  while ( true )  { \n     if ( file   was   modified ) \n     { \n         string   filePath   =   System . IO . File . ReadAllText ( file   path ); \n         ImaginationOverflow . UniversalFileAssociation . FileAssociationManager . Instance . ManuallyTriggerActivation ( filePath ,   new   StringReader ( filePath ),   ( ulong ) new   FileInfo ( filePath ). Length ;); \n     }  }   The launcher application needs to check if the app/game is open or not before deciding which method it would use in order to send the activation data to it. If the application is not running, you can simply launch it and pass the  activated file path  as an argument. If the app/game is already running, you need to IPC in order to send information to the running app/game. Using the file polling example again, the launcher application code can be something like:  void   Main ( string []   args )  { \n     if ( args . Length   ==   0 ) \n         return ; \n\n     //  Get the activation file path. \n     var   filePath   =   args [ 1 ]; \n\n     //  Check if your app/game is running \n     if ( Process . GetProcessesByName ( your app/game ). Length   ==   0 ) \n     { \n         //if not simply launch it with the file path as argument \n         Process   p   =   new   Process (); \n         p . StartInfo   =   new   ProcessStartInfo ( path to app/game executable ,   filePath ); \n         p . Start (); \n     } \n     else \n     {    \n         // \n         //  Write in the share file the file path so that the app/game can extract it \n         // \n         File . WriteAllText ( Path to shared file between launcher and game ,   filePath ); \n     }  }", 
            "title": "Standalone activation after launch"
        }, 
        {
            "location": "/Internals/#mac", 
            "text": "All manifest registrations are handled by the plugin, the file activation is deferred from our library into the game as it happens, so MacOs builds won't have the caveats that Windows and Linux have.  In order to support file activation we had to make a  library  ( UniversalFileAssociation.framework ) that would intercept the activation events of the application itself since Unity doesn't allow the plugin to automatically link a library on the build process it must be done after the build. To make that possible the plugin includes the tool  optool .   optool allow us to inject the library into the game and collect all the activation events. If you build your game on MacOs the plugin  will automatically  call optool and inject the library. If you make the build on any other OS you will need to make an extra step, just has explained on the  Getting Started Section .   This requirement exists because optool was made for MacOs and the team couldn't in useful time port it to Windows.  For more info about how the library injection works check  here .", 
            "title": "Mac"
        }, 
        {
            "location": "/About/", 
            "text": "ImaginationOverflow is a polyvalent group of people that come together in order to make software. They specialize in Apps made with Xamarin and Unity games. As indies, they published dozen of apps and games.\n\n\nAuthors\n\n\nDiogo Cardoso\n - \nTwitter\n --- \nLinkedIn\n\n\nAna Correia\n - \nLinkedIn\n\n\nLinks\n\n\nWebsite\n\n\nTwitter\n\n\nFacebook\n\n\nSteam Page\n\n\nPlay Store\n\n\nApp Store\n\n\nMicrosoft Store\n\n\nDiscord Server\n\n\nContact Email\n\n\nBlog\n\n\nAcknowledgements\n\n\n\n\nThe portuguese gamedev community for suggestions and support.\n\n\nGeri Borb\u00e1s\n for his awesome articles regarding unity plugins and library injection on MacOs\n\n\nAlex Zielenski\n for creating optool and open it for the community\n\n\nOur Patrons, Eric T, Tom T, Michael, Abdullah T", 
            "title": "About"
        }, 
        {
            "location": "/About/#authors", 
            "text": "Diogo Cardoso  -  Twitter  ---  LinkedIn  Ana Correia  -  LinkedIn", 
            "title": "Authors"
        }, 
        {
            "location": "/About/#links", 
            "text": "Website  Twitter  Facebook  Steam Page  Play Store  App Store  Microsoft Store  Discord Server  Contact Email  Blog", 
            "title": "Links"
        }, 
        {
            "location": "/About/#acknowledgements", 
            "text": "The portuguese gamedev community for suggestions and support.  Geri Borb\u00e1s  for his awesome articles regarding unity plugins and library injection on MacOs  Alex Zielenski  for creating optool and open it for the community  Our Patrons, Eric T, Tom T, Michael, Abdullah T", 
            "title": "Acknowledgements"
        }
    ]
}